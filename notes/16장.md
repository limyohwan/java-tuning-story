# 16. JVM은 도대체 어떻게 구동될까?
- 자바 성능 개선을 위해 Just In Time(JIT) 컴파일러를 만들었고 이름을 HotSpot으로 지었다
- JIT 컴파일러는 프로그램의 성능에 영향을 주는 지점을 분석하여 그 지점의 부화를 최소화하고 최적화한다
- HotSpot VM
    - VM(Virtual Machine) 런타임
    - JIT(Just In Time) 컴파일러: 자바 메서드가 호출되면 바이트 코드를 컴파일하고 실행 가능한 네이티브 코드로 변환함
    - 메모리 관리자
- JIT Optimizer
    - 수행 카운터: 메서드를 시작할 때마다 증가(XX:CompileThreshold)
    - 백에지 카운터: 높은 바이트 코드 인덱스에서 낮은 인덱스로 컨트롤 흐름이 변경될 때마다 증가, 메서드가 루프가 존재하는지를 확인하며 수행 카운터 보다 컴파일 우선순위가 높음(XX:CompileTreshold * XX:OnStackReplacePercentage / 100)
    - 위의 카운터에 사용하는 한계치에 도달할 경우 컴파일을 요청함 -> 컴파일 대상 목로의 큐에 쌓임 -> 컴파일러 스레드가 큐를 모니터링 하다가 컴파일러 스레드가 바쁘지 않을 때 큐에서 대상을 뺴내서 컴파일을 시작함
- JVM 시작 절차
    - 1 클래스 실행
    - 2 java 명령어 줄에 있는 옵션 파싱
    - 3 자바 힙 크기 할당 및 JIT 컴파일러 타입 지정
    - 4 CLASSPATH와 LD_LIBRARY_PATH 같은 환경 변수 지정
    - 5 자바 Main 클래스가 지정되지 않았으면, Jar 파일의 mainfest 파일에서 Main 클래스 확인
    - 6 JNI의 표준 API인 JNI_CreateJavaVM를 사용하여 새로 생성한 non-primordial이라는 스레드에서 HotSpot VM을 생성함
        - 자바의 가상 머신(JVM)을 생성하는 JNI_CreateJavaVM 단계
        - 1 동시에 두개의 스레드에서 호출할 수 없고 오직 하나의 HotSpot VM 인스턴스가 프로세스 내에서 생성될 수 있도록 보장함
        - 2 JNI 버전이 호환성이 있는지 점검하고 GC 로깅을 위한 준비도 완료됨
        - 3 OS 모듈들이 초기화됨(랜덤 번호 생성기, PID 할당)
        - 4 커맨드 라인 변수와 속성들이 JNI_CreateJavaVM 변수에 전달되고 나중에 사용하기 위해 파싱 후 보관함
        - 5 표준 자바 시스템 속성(properties)이 초기화됨
        - 6 동기화, 메모리, safepoint 페이지와 같은 모듈들이 초기화됨
        - 7 libzip, libhpi, libjava, libthread와 같은 라이브러리들이 로드됨
        - 8 시그널 처리기가 초기화 및 설정됨
        - 9 스레드 라이브러리가 초기화됨
        - 10 출력(output)스트림 로거가 초기화됨
        - 11 JVM을 모니터링하기 위한 에이전트 라이브러리가 설정되어 있으면 초기화 및 시작됨
        - 12 스레드 처리를 위해서 필요한 스레드 상태와 스레드 로컬 저장소가 초기화됨
        - 13 HotSpot VM의 글로벌 데이터(이벤트 로그, OS동기화, 성능 통계메모리/perfMemory, 메모리 할당자/chunkPool)들이 초기화됨
        - 14 HotSpot VM에서 스레드를 생성할 수 있는 상태가 되며 main 스레드가 생성되고 현재 OS 스레드에 붙음
        - 15 자바 레벨의 동기화가 초기화 및 활성화됨
        - 16 부트 클래스로더, 코드 캐시, 인터프리터, JIT 컴파일러, JNI, 시스템 dictionary, '글로벌 데이터' 구조의 집합인 universe 등이 초기화됨
        - 17 스레드 목록에 자바 main 스레드가 추가되고, universe의 상태를 점검하며 HotSpot VM의 중요한 기능을 하는 HotSpot VMThread가 생성되며 현재 상태를 JVMTI에 전달함
        - 18 java.lang 패키지에 있는 String, System, Thread, ThreadGroup, Class 클래스와 java.lang 하위 패키지에 있는 Method, Finalizer 클래스 등이 로딩되고 초기화됨
        - 19 HotSpot VM의 시그널 핸들러 스레드가 시작되고, JIT 컴파일러가 초기화 되며, HotSpot의 컴파일 브로커 스레드가 시작되며 HotSpot VM과 관련된 각종 스레드들이 시작함(HotSpot VM 전체 기능 동작)
        - 20 JNIEnv가 시작되며, HotSpot VM을 시작한 호출자에게 새로운 JNI 요청을 처리할 상황이 되었다고 전달함
    - 7 HotSpot VM이 생성되고 초기화되면, Main 클래스가 로딩된 런처에서는 main() 메서드의 속성 정보를 읽음
    - 8 CallStaticVoidMethod는 네이티브 인터페이스를 불러 HotSpot VM에 있는 main() 메서드가 수행되며 이때 자바 실행 시 Main 클래스 뒤에 있는 값들이 전달됨
- JVM 종료 절차(kill -9 같은 명령어로 종료하면 이 절차를 따르지 않음)
    - 1 HotSpot 런처에서 DestroyJavaVM 메서드를 호출함
    - 2 HotSpot VM이 작동중인 상황에서는 단 하나의 데몬이 아닌 스레드(nondaemon thread)가 수행될 때까지 대기함
    - 3 java.lang 패키지에 있는 Shutdown클래스의 shutdown()메서드가 수행되며 그 후 자바 레벨의 shutdown hook이 수행되고 finalization-on-exit이라는 값이 tru일 경우에 자바 객체 finalizer를 수행함
    - 4 HotSpot VM 레벨의 shutdown hook을 수행함으로써 HotSpot VM의 종료를 준비하는 작업이 JVM_OnExit() 메서드를 통해 지정되며 HotSpot VM의 profiler, stat sampler, watcher, garbage collector 스레드를 종료시키고 이 작업들이 종료되면 JVMTI를 비활성화하며 Signal 스레드를 종료시킴
    - 5 HotSpot의 JavaThread::exit() 메서드를 호출하여 JNI 처리 블록을 해체한 후 guard pages, 스레드 목록에 있는 스레드들을 삭제함 -> 이 순간부터는 HotSpot VM에서 자바 코드를 실행하지 못함
    - 6 HotSpot VM 스레드를 종료한 후 HotSpot VM에 남아있는 HotSpot VM 스레드들을 safepoint로 옮기고, JIT 컴파일러 스레드들을 중지시킴
    - 7 JNI, HotSpot VM, JVMTI barrier에 있는 추적(tracing) 기능을 종료시킴
    - 8 네이티브 스레드에서 수행하고 있는 스레드들을 위해서 HotSpot의 "vmexited" 값을 설정함
    - 9 현재 스레들을 삭제함
    - 10 입출력 스트림을 삭제하고, PerfMemory 리소스 연결을 해제함
    - 11 JVM 종료를 호출한 호출자로 복귀함
- 클래스 로딩 절차: 자바 클래스가 메모리에 로딩되는 절차, loading -> linking -> linitializing
    - 1 주어진 클래스의 이름으로 클래스 패스에 있는 바이너리로 된 자바 클래스를 찾음
    - 2 자바 클래스를 정의함
    - 3 해당 클래스를 나타내는 java.lang 패키지의 Class 클래스의 객체를 생성함
    - 4 링크 작업이 수행되며 static 필드를 생성 및 초기화하고, 메서드 테이블을 할당함
    - 5 클래스의 초기화가 진행되며 클래스의 static 블록과 static 필드가 가장 먼저 초기화되며 해당 클래스가 초기화 되기 전에 부모 클래스의 초기화가 먼저 이루어짐