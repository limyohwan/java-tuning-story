# 17. 도대체 GC는 언제 발생할까?
- Full GC를 수행하는 시점에 해당 JVM에서 처리되지 않으며 GC를 많이 할 수록 응답 시간에 영향을 끼친다
- Runtime Data Area
    - PC 레지스터
    - JVM 스택
    - 힙(Heap): GC가 발생하는 영역
    - 메서드 영역
    - 런타임 상수(constant) 풀
    - 네이티브 메서드 스택
- 자바의 메모리영역은 크게 Heap 메모리와 Non-heap 메모리로 나뉜다
- Heap 메모리
    - 공유(shared) 메모리
    - 여러 스레드에서 공유하는 데이터들이 저장되는 메모리
- Non-heap 메모리
    - 자바의 내부 처리를 위해서 필요한 영역(메서드 영역, 런타임 상수풀, 메서드 데이터, 메서드, 생성자 코드, JVM 스택, 네이티브 메서드 스택, PC 레지스터 등)
- GC의 원리
    - 메모리 할당
    - 사용 중인 메모리 인식
    - 사용하지 않는 메모리 인식
- hang: 서버에서 요청을 처리 못하는 상태
- 자바 메모리 영역
    - Young
        - Eden
        - Survivor 1
        - Survivor 2
    - Old
    - Perm: 거의 사용하지 않음
    - Virtual: 가상 영역이므로 고려하지 않음
- GC 과정
    - 1 객체가 생성되면 Eden 영역에 저장된다
    - 2 Eden 영역 데이터가 꽉차면 Survivor 1 2 중 한 영역(둘중 한군데는 비어있어야함)에 데이터가 옮겨지거나 삭제된다(마이너 GC)
    - 3 Eden 영역에서 데이터가 꽉 차면 또 마이너 GC가 일어나고 Survivor 1 2 중 비어있는 영역으로 데이터가 옮겨지거나 삭제되며 기존 데이터가 차있는 Survivor 영역 데이터도 비어있는 Survivor 영역으로 옮겨진다
    - 4 이렇게 Survivor 영역 1과 2를 왔다 갔다하다가 Old 영역으로 옮겨지며 객체의 크기가 큰 경우에는 Eden영역에서 바로 Old 영역으로 옮겨질 수도 있다
    - 5 Old 영역에서 데이터가 꽉차 데이터를 삭제하게 된다(메이저 GC, Full GC)
- 마이너 GC: Young 영역에서 발생하는 GC
- 메이저 GC: Old 영역이나 Perm 영역에서 발생하는 GC